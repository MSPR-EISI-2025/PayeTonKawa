name: Deploy via SSH

on:
  workflow_dispatch:         # déclenchement manuel
  
env:
  DOCKERHUB_REPO: bowo73/payetonkawa     # repo Docker Hub
  DEPLOY_PATH: /home/${{ secrets.SSH_USER }}/PayeTonKawa   # dossier cible sur le serveur
  ENV_FILE: .env.prod.sample           # env-file à utiliser côté serveur
  PROFILE: inporter                    # profile docker compose à activer
  API_SERVICES: backend_clients backend_orders backend_product

permissions:
  contents: read

jobs:
  deploy_ssh:
    name: Deploy via SSH (docker compose)
    runs-on: ubuntu-latest
    env:
      DOCKERHUB_REPO: bowo73/payetonkawa        
      DEPLOY_PATH: /home/${{ secrets.SSH_USER }}/PayeTonKawa
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: false

      - name: Decide channel tag (ci-main|ci-develop)
        id: ch
        run: |
          if [ "${GITHUB_REF_NAME}" = "main" ]; then
            echo "channel=ci-main" >> $GITHUB_OUTPUT
          else
            echo "channel=ci-develop" >> $GITHUB_OUTPUT
          fi

      # genere un override compose avec image: bowo73/payetonkawa:<service>-<channel>
      - name: Make compose.deploy.yml (from services with build:)
        env:
          CHANNEL: ${{ steps.ch.outputs.channel }}
        run: |
          python3 - <<'PY' > compose.deploy.yml
          import yaml, sys, os
          with open('docker-compose.yml') as f:
              data = yaml.safe_load(f) or {}
          svcs = {n:s for n,s in (data.get('services') or {}).items() if isinstance(s, dict) and 'build' in s}
          if not svcs:
              sys.exit("No buildable services found")
          chan = os.environ['CHANNEL']
          repo = os.environ.get('DOCKERHUB_REPO','bowo73/payetonkawa')
          out = {'version': '3.9','services': {}}
          for name in svcs:
              out['services'][name] = {'image': f"{repo}:{name}-{chan}"}
          yaml.safe_dump(out, sys.stdout, sort_keys=False)
          PY
          echo "----- compose.deploy.yml -----"
          cat compose.deploy.yml

      # verif que les fichiers existent
      - name: Check files before upload
        run: |
          set -e
          ls -lah
          test -f docker-compose.yml || { echo "docker-compose.yml manquant à la racine"; exit 1; }
          test -f compose.deploy.yml || { echo "compose.deploy.yml manquant (step de génération non exécutée ?)"; exit 1; }
          if [ -f .env.prod.sample ]; then
            echo ".env.prod.sample présent"
          else
            echo "::warning::.env.prod.sample non trouvé, on l'ignorera pour l'upload"
          fi

      # construire la liste 'source' (format attendu: chemins separes par des virgules)
      - name: Build upload source list
        id: upl
        shell: bash
        run: |
          set -e
          FILES=(docker-compose.yml compose.deploy.yml)
          [ -f .env.prod.sample ] && FILES+=(".env.prod.sample")
          LIST=$(printf "%s," "${FILES[@]}" | sed 's/,$//')
          echo "list=$LIST" >> "$GITHUB_OUTPUT"
          echo "UPLOAD_SOURCES=$LIST" >> "$GITHUB_ENV"
          echo " Upload sources: $LIST"

      - name: Probe SSH reachability (no deps)
        shell: bash
        run: |
          set -e
          HOST='${{ secrets.SSH_HOST }}'
          PORT='${{ secrets.SSH_PORT }}'
          : "${PORT:=22}"
          echo "Probing $HOST:$PORT ..."
          if timeout 7 bash -c ">/dev/tcp/$HOST/$PORT"; then
            echo "TCP open"
          else
            echo "Can't reach $HOST:$PORT"; exit 1
          fi


      # créer le répertoire cible côté serveur
      #- name: Ensure remote folder exists
       # uses: appleboy/ssh-action@v1.0.3
       # with:
        #  host: ${{ secrets.SSH_HOST }}
         # username: ${{ secrets.SSH_USER }}
          #key: ${{ secrets.SSH_PRIVATE_KEY }}
          #port: ${{ secrets.SSH_PORT }}
          #script: |
          #  ls /PayeTonKawa
      - name: Make compose.deploy.yml (APIs only)
        env:
          CHANNEL: ${{ steps.ch.outputs.channel }}
        run: |
          python3 - <<'PY' > compose.deploy.yml
          import os, sys, yaml
          repo    = os.environ['DOCKERHUB_REPO']
          chan    = os.environ['CHANNEL']
          apis    = (os.environ.get('API_SERVICES') or '').split()
          if not apis: sys.exit("No API_SERVICES defined")
          with open('docker-compose.yml') as f:
              base = yaml.safe_load(f) or {}
          existing = set((base.get('services') or {}).keys())
          miss = [s for s in apis if s not in existing]
          if miss: print(f"Services absents dans compose: {miss}", file=sys.stderr)
          out = {'services': {s: {'image': f'{repo}:{s}-{chan}'} for s in apis if s in existing}}
          yaml.safe_dump(out, sys.stdout, sort_keys=False)
          PY
          echo "----- compose.deploy.yml -----"
          cat compose.deploy.yml
          
      # upload sans archive vide
      - name: Upload compose files to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT || 22 }}
          # IMPORTANT: liste separe par des virgules (pas de multilignes)
          source: ${{ steps.upl.outputs.list }}
          target: ${{ env.DEPLOY_PATH }}


      # connexion ssh et deploiement
      - name: Deploy on server (pull & up)
        uses: appleboy/ssh-action@v1.0.3
        env:                                  #on charge les secrets dans l'env du step
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
          DEPLOY_PATH: ${{ env.DEPLOY_PATH }}
          ENV_FILE: ${{ env.ENV_FILE }}
          PROFILE: ${{ env.PROFILE }}
          API_SERVICES: ${{ env.API_SERVICES }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.SSH_PORT || 22 }}
          envs: DOCKER_USERNAME,DOCKER_PASSWORD,DEPLOY_PATH,ENV_FILE,PROFILE,API_SERVICE #export vers la session ssh
          script: |
            set -e
            cd "${DEPLOY_PATH}"
            echo "$DOCKER_PASSWORD" | docker login -u "$DOCKER_USERNAME" --password-stdin
            docker-compose -f docker-compose.yml -f compose.deploy.yml pull ${API_SERVICES}
            docker-compose -f docker-compose.yml -f compose.deploy.yml  -d --remove-orphans ${API_SERVICES}


